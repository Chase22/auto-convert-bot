//! [`Insertable`](../../diesel/prelude/trait.Insertable.html) and
//! [`Queryable`](../../diesel/deserialize/trait.Queryable.html) types used by
//! the [`diesel`](http://docs.diesel.rs/diesel/index.html) crate to insert into and query the
//! database respectively.
//!
//! One dictionary table entry, joined with definednames and longhands, all joined with chatsettings
//! on the chat_id, represents one dictionary entry in [ChatSettings](../struct.ChatSettings.html).
//! (See the ERD AutoConvertBot_Tables.drawio in Github for a visual representation.)

use super::schema::{chatsettings, definednames, dictionary, longhands};

use telegram_bot::*;
use uuid;
use std::cmp::Ordering;

/// [`Insertable`](../../diesel/prelude/trait.Insertable.html) struct for
/// table chatsettings.
#[derive(Insertable)]
#[table_name = "chatsettings"]
pub struct NewChatSettings {
    pub chat_id: Integer,
    pub whole_message_always: bool,
}

impl NewChatSettings {
    /// Simple Constructor.
    pub fn new(chat_id: Integer, whole_message_always: bool) -> Self {
        Self {
            chat_id,
            whole_message_always,
        }
    }
}

/// [`Queryable`](../../diesel/deserialize/trait.Queryable.html) struct for
/// table chatsettings
#[derive(Queryable, Debug)]
pub struct FetchedChatSettings {
    pub chat_id: Integer,
    pub whole_message_always: bool,
}

/// [`Insertable`](../../diesel/prelude/trait.Insertable.html) struct for
/// table definednames
#[derive(Insertable)]
#[table_name = "definednames"]
pub struct NewDefinedNames {
    pub chat_id: Integer,
    pub short_hand: String,
}

impl NewDefinedNames {
    /// Constructor for entry in table definednames, the
    /// [`Uuid`](../../uuid/struct.Uuid.html) `name_id` is generated by the
    /// Database at time of insertion to guarantee uniqueness.
    pub fn new(chat_id: Integer, short_hand: String) -> Self {
        Self {
            chat_id,
            short_hand,
        }
    }
}

/// [`Queryable`](../../diesel/deserialize/trait.Queryable.html) struct for
/// table definednames
#[derive(Queryable, Debug, Eq)]
pub struct FetchedDefinedNames {
    pub name_id: uuid::Uuid,
    pub chat_id: Integer,
    pub short_hand: String,
}

impl Ord for FetchedDefinedNames {
    /// Sort by [`Uuid`](../../uuid/struct.Uuid.html) to allow sorting of
    /// query results, so that the multiple longhand entries per contiguous
    /// [`ChatSettings`](../struct.ChatSettings.html) entry can appear next to each other.
    fn cmp(&self, other: &Self) -> Ordering {
        self.name_id.cmp(&other.name_id)
    }
}

impl PartialOrd for FetchedDefinedNames {
    /// Identical to Ord, creating a complete Order.
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for FetchedDefinedNames {
    fn eq(&self, other: &Self) -> bool {
        self.name_id == other.name_id
    }
}

/// [`Insertable`](../../diesel/prelude/trait.Insertable.html) struct for
/// table dictionary
///
/// Before creating a [NewDictionary]() the
/// [`Uuid`](../../uuid/struct.Uuid.html) of the key and value pair in the
/// dictionary being inserted into the Database must be fetched from table definednames.
#[derive(Insertable)]
#[table_name = "dictionary"]
pub struct NewDictionary {
    /// The [`Uuid`](../../uuid/struct.Uuid.html) from
    /// [FetchedDefinedNames](struct.FetchedDefinedNames.html) representing the key.
    pub name_id_source: uuid::Uuid,
    /// The [`Uuid`](../../uuid/struct.Uuid.html) from
    /// [FetchedDefinedNames](struct.FetchedDefinedNames.html) representing the value.
    pub name_id_target: uuid::Uuid,
    /// The `f64` conversion rate.
    pub conversion_rate: f64,
}

impl NewDictionary {
    /// Simple Constructor for insertion into table dictionary.
    ///
    /// Takes the [`Uuid`](../../uuid/struct.Uuid.html)s of the definednames
    /// entries that map from key to value in the dictionary.
    pub fn new(
        name_id_source: uuid::Uuid,
        name_id_target: uuid::Uuid,
        conversion_rate: f64,
    ) -> Self {
        Self {
            name_id_source,
            name_id_target,
            conversion_rate,
        }
    }
}

/// [`Queryable`](../../diesel/deserialize/trait.Queryable.html) struct for
/// table dictionary
#[derive(Queryable, Debug)]
pub struct FetchedDictionary {
    /// The [`Uuid`](../../uuid/struct.Uuid.html) representing the key.
    pub name_id_source: uuid::Uuid,
    /// The [`Uuid`](../../uuid/struct.Uuid.html) representing the value.
    pub name_id_target: uuid::Uuid,
    /// The f64 conversion rate.
    pub conversion_rate: f64,
}

/// [`Insertable`](../../diesel/prelude/trait.Insertable.html) struct for
/// table longhands
///
/// Before creating a [NewLongHands]() the
/// [`Uuid`](../../uuid/struct.Uuid.html) of the [`Unit`](../struct.Unit.html)
#[derive(Insertable)]
#[table_name = "longhands"]
pub struct NewLongHands {
    /// The [`Uuid`](../../uuid/struct.Uuid.html) representing the
    /// [`Unit`](../struct.Unit.html).
    pub name_id: uuid::Uuid,
    /// One of the long-hands from [`Unit`](../struct.Unit.html).
    pub long_hand: String,
}

impl NewLongHands {
    /// Simple Constructor for [`NewLongHands`]().
    ///
    /// Requires fetching the [`Uuid`](../../uuid/struct.Uuid.html) of the
    /// definedname entry this longhand entry belongs to before insertion using
    /// [FetchedDefinedNames](struct.FetchedDefinedNames.html).
    pub fn new(name_id: uuid::Uuid, long_hand: String) -> Self {
        Self { name_id, long_hand }
    }
}

/// [`Queryable`](../../diesel/deserialize/trait.Queryable.html) struct for
/// table longhands
#[derive(Queryable, Debug)]
pub struct FetchedLongHands {
    /// The [`Uuid`](../../uuid/struct.Uuid.html) representing the
    /// [`Unit`](../struct.Unit.html).
    pub name_id: uuid::Uuid,
    /// A long-hand for [`Unit`](../struct.Unit.html).
    pub long_hand: String,
}
